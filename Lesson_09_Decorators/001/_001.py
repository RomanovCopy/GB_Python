

# def func01(str1):
#     array=[]
#     print(str1)
#     def func02(str2):
#         array.append(str2)
#         return str1+', '+ ', '.join(array)
#     return func02


# a = func01('Sergey')
# print(a('Romanov'))
# print(a('Mihailovich'))
# print(func01('Romanov')('Sergey'))

###############################################################################################


# def main(x:int):
#     d={}
#     def loc(y:int):
#         d.clear()
#         for i in range(y):
#             d[i]=x**i
#         return d
#     return loc

# small=main(42)
# big=main(73)
# print(small(7), big(7), small(3))

###########################################################################################

# from typing import Callable
# import time


# def main(func:Callable):
#     def wrapper(*args, **kwargs):
#         #Использование `time.perf_counter()` вместо  'time.time()' 
#         #обеспечит более точные временные измерения и 
#         #позволит различать время старта и завершения функции даже для случая с большими 
#         #значениями параметра.
#         start_time = time.perf_counter()
#         print(f'Запуск функции {func.__name__} в {start_time}')
#         result = func(*args, **kwargs)
#         end_time = time.perf_counter()
#         print(f'Результат функции {func.__name__}: {result}')
#         print(f'Завершение функции {func.__name__} в {end_time}')
#         return result
#     return wrapper

# @main
# def factorial(n: int) -> int:
#     f=1
#     for i in range(2, n+1):
#         f*=i
#     return f



# print(f'{factorial(500) = }')

#######################################################################################

# порядок запуска и завершения декораторов для функции определяется последовательностью их определения. 
# При применении нескольких декораторов к одной функции они выполняются последовательно, но завершаются в 
# обратном порядке - сначала завершается самый внутренний декоратор, а затем остальные в обратном порядке.

# def decorator1(func):
#     print("Начало работы декоратора 1")
#     def wrapper(*args, **kwargs):
#         print("Выполнение декоратора 1 до вызова функции")
#         result = func(*args, **kwargs)
#         print("Выполнение декоратора 1 после вызова функции")
#         return result
#     print("Завершение работы декоратора 1")
#     return wrapper

# def decorator2(func):
#     print("Начало работы декоратора 2")
#     def wrapper(*args, **kwargs):
#         print("Выполнение декоратора 2 до вызова функции")
#         result = func(*args, **kwargs)
#         print("Выполнение декоратора 2 после вызова функции")
#         return result
#     print("Завершение работы декоратора 2")
#     return wrapper

# def decorator3(func):
#     print("Начало работы декоратора 3")
#     def wrapper(*args, **kwargs):
#         print("Выполнение декоратора 3 до вызова функции")
#         result = func(*args, **kwargs)
#         print("Выполнение декоратора 3 после вызова функции")
#         return result
#     print("Завершение работы декоратора 3")
#     return wrapper

# @decorator1
# @decorator2
# @decorator3
# def example_function():
#     print("Выполнение основной функции")

# example_function()

# В Python все определенные декораторы будут храниться в памяти до завершения выполнения программы или до удаления объекта, к которому они применены. Когда декораторы применяются к функциям или классам, они сохраняют ссылки на обернутые функции или классы во время исполнения программы.

# При использовании декораторов, каждый декоратор создает и возвращает новую функцию-обертку, которая содержит ссылку на исходную функцию. Эти функции-обертки затем используются вместо исходных функций в дальнейшем коде.

# Поэтому пока программа выполняется, все декораторы и функции-обертки, созданные ими, остаются в памяти. Когда декорируемая функция вызывается, все декораторы, касающиеся этой функции, будут исполняться последовательно, и каждый из них оставляет след в памяти до завершения этой функции.

# Когда программа завершается или объект, к которому применены декораторы, удаляется, тогда и декораторы будут удалены из памяти сборщиком мусора Python во время очистки памяти. Пока программа активна, использованные декораторы и функции-обертки будут оставаться в памяти.




##########################################################################################




# from typing import Callable

# def cache(func: Callable):
#     _cache_dict={}
    
#     def wrapper(*args):
#         if args not in _cache_dict:
#             _cache_dict[args]=func(*args)
#         return _cache_dict[args]
    
#     return wrapper


# @cache
# def factorial(n: int) -> int:
#     print(f'Вычисляю факториал для числа {n}')
#     f=1
#     for i in range(2, n+1):
#         f*=i
#     return f

# print(factorial(15))
# print(factorial(20))
# print(factorial(15))




#########################################################################################




# В этом примере `multiply_by` - это фабрика декораторов, которая принимает параметр `n` и 
# возвращает декоратор. Декоратор оборачивает функцию `add_ten`, умножая результат этой функции на значение `n`, которое было передано в `multiply_by`.

# Когда мы вызываем `add_ten(3)`, декоратор умножит результат выполнения `add_ten` (3 + 10 = 13) на 5 из замыкания, получая итоговый результат 65.

# Таким образом, декоратор в данном случае замыкается на переменной `n`, переданной в `multiply_by`, 
# и использует ее значение при выполнении функции `add_ten`, что позволяет создать замыкание 
# и использовать дополнительную переменную в декораторе.

# def multiply_by(n):
#     def decorator(func):
#         def wrapper(x):
#             result = func(x) * n
#             return result
#         return wrapper
#     return decorator

# @multiply_by(5)
# def add_ten(x):
#     return x + 10

# result = add_ten(3)
# print(f"Результат вызова функции add_ten(3): {result}")

##########################################################################################


# import time
# from typing import Callable
# from functools import cache, wraps

# def count(num:int=1):
#     def deco(func:Callable):
#         @wraps(func)
#         def wrapper(*args, **kwargs):
#             time_for_count=[]
#             result=None
#             for _ in range(num):
#                 start=time.perf_counter()
#                 result=func(*args, **kwargs)
#                 stop=time.perf_counter()
#                 time_for_count.append(stop-start)
#             print(f'Результаты замеров {time_for_count}')
#             return result
#         return wrapper
#     return deco


# @count(10)
# def factorial(n: int) -> int:
#     """Вычисляем факториал числа n"""
#     print(f'Вычисляю факториал для числа {n}')
#     f=1
#     for i in range(2, n+1):
#         f*=i
#     return f

# print(f'{factorial(1000) = }')
# print(f'{factorial.__name__ = }')
# help(factorial)


# Декоратор `@wraps` из модуля `functools` в Python предоставляет возможность сохранять метаданные и атрибуты из оригинальной функции в функцию-обертку, что делает работу с декораторами более прозрачной и упрощает отладку кода. В основном `@wraps` используется для "поворачивания" декоратора вокруг функции с тем, чтобы сохранить информацию об исходной функции. 

# Почему это важно:

# 1. Сохранение документации: Декоратор `@wraps` позволяет сохранить документацию (docstring) и другие метаданные оригинальной функции, что помогает при использовании функции и понимании ее назначения.

# 2. Сохранение атрибутов функции: Декоратор `@wraps` также сохраняет другие атрибуты функции, такие как имя функции, аргументы, аннотации и любые другие пользовательские атрибуты, которые могли бы быть присвоены функции.

# 3. Отладка: Сохранение метаданных функции делает отладку кода проще, поскольку имена и другие атрибуты будут сохранены в обернутой функции.


#########################################################################################
import time
from typing import Callable
from functools import cache


@cache
def factorial(n: int) -> int:
    """Вычисляем факториал числа n"""
    print(f'Вычисляю факториал для числа {n}')
    f=1
    for i in range(2, n+1):
        f*=i
    return f

print(f'{factorial(10) = }')
print(f'{factorial(15) = }')
print(f'{factorial(10) = }')
print(f'{factorial(20) = }')
print(f'{factorial(25) = }')
print(f'{factorial(20) = }')



# Декоратор `@cache` в Python обусловлен его применением для кеширования результатов выполнения функции. Кеширование - это техника, которая сохраняет результаты дорогостоящих вычислений, таких как вызовы функций с большими объемами данных или сложными расчетами, чтобы избежать повторного вычисления при повторных вызовах функции с одними и теми же аргументами.

# Обычно декоратор `@cache` сохраняет результаты выполнения функции во внутреннем кеше и возвращает сохраненный результат, если функция вызывается с аргументами, для которых результат уже был рассчитан и сохранен.




# def cache(func):
#     cached_results = {}  # Хранилище для кэша результатов функции

#     def wrapper(*args):
#         if args in cached_results:  # Если результат уже кеширован
#             print(f"Используется кеш для аргументов: {args}")
#             return cached_results[args]
#         else:
#             result = func(*args)
#             cached_results[args] = result  # Сохранить результат в кеш
#             return result

#     return wrapper

# @cache
# def expensive_function(n):
#     print(f"Выполнение дорогостоящей функции для аргументов: {n}")
#     return n * n

# print(expensive_function(5))
# print(expensive_function(5))  # Повторный вызов с теми же аргументами - результат будет взят из кэша
# print(expensive_function(10))
